<!DOCTYPE html>
<html>
<head>
    <title>Simple Game</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #character { font-size: 24px; margin: 20px; }
        #map {
            display: block;
            width: 800px;
            height: 600px;
            margin: 20px auto;
            border: 1px solid black;
            background: linear-gradient(135deg, #87ceeb 0%, #98fb98 100%);
        }
        button { margin: 10px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h1>Simple Character Game</h1>
    <div id="character">Character at (0, 0) - Health: 100</div>
    <canvas id="map" width="800" height="600"></canvas>
    <div>
        <button onclick="move('up')">Up</button><br>
        <button onclick="move('left')">Left</button>
        <button onclick="move('right')">Right</button><br>
        <button onclick="move('down')">Down</button>
    </div>
    <script>
        let ws;
        let playerId = localStorage.getItem('playerId');

        if (!playerId) {
            playerId = generatePlayerId();
            localStorage.setItem('playerId', playerId);
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function connectWebSocket() {
            ws = new WebSocket('ws://127.0.0.1:8080/ws', [], {
                headers: { 'x-player-id': playerId }
            });

            // WebSocket constructor doesn't support headers in browser
            // We need to use a different approach - send the player ID in the first message
            ws.onopen = function(event) {
                console.log('WebSocket connected, sending player ID:', playerId);
                ws.send(JSON.stringify({ playerId: playerId }));
                // Wait a bit for the server to process the player ID before updating map
                setTimeout(updateMap, 100);
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateMapFromData(data.players, data.map);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onclose = function(event) {
                console.log('WebSocket closed, reconnecting...');
                setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        async function updateMap() {
            try {
                const [mapResponse, charResponse] = await Promise.all([
                    fetch('/map'),
                    fetch('/character', {
                        headers: { 'x-player-id': playerId }
                    })
                ]);

                if (!mapResponse.ok || !charResponse.ok) {
                    throw new Error('Failed to fetch game data');
                }

                const map = await mapResponse.json();
                const char = await charResponse.json();
                updateMapFromData({ [playerId]: char }, map);
            } catch (error) {
                console.error('Error updating map:', error);
            }
        }

        function updateMapFromData(players, map) {
            const canvas = document.getElementById('map');
            const ctx = canvas.getContext('2d');

            // Очистка canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const tileWidth = 40;
            const tileHeight = 20;
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2 - 100;

            // Рисуем тайлы
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    const isoX = (x - y) * (tileWidth / 2) + offsetX;
                    const isoY = (x + y) * (tileHeight / 2) + offsetY;

                    // Рисуем ромб
                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY - tileHeight / 2);
                    ctx.lineTo(isoX + tileWidth / 2, isoY);
                    ctx.lineTo(isoX, isoY + tileHeight / 2);
                    ctx.lineTo(isoX - tileWidth / 2, isoY);
                    ctx.closePath();

                    // Цвет тайла
                    if (map.tiles[y][x] === 'wall') {
                        ctx.fillStyle = '#666';
                        ctx.strokeStyle = '#333';
                    } else {
                        ctx.fillStyle = '#90ee90';
                        ctx.strokeStyle = '#32cd32';
                    }
                    ctx.fill();
                    ctx.stroke();

                    // Проверяем, есть ли игрок на этой клетке
                    let playerHere = null;
                    for (const [id, char] of Object.entries(players)) {
                        if (x === char.x && y === char.y) {
                            playerHere = id;
                            break;
                        }
                    }

                    if (playerHere) {
                        // Рисуем игрока
                        ctx.beginPath();
                        ctx.arc(isoX, isoY, 12, 0, 2 * Math.PI);
                        ctx.fillStyle = playerHere === playerId ? '#ffd700' : '#ff6b6b';
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Текст игрока
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(playerHere === playerId ? 'P' : 'O', isoX, isoY + 4);
                    } else if (map.tiles[y][x] === 'wall') {
                        // Стена
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('#', isoX, isoY + 5);
                    }
                }
            }

            const currentChar = players[playerId];
            if (currentChar) {
                document.getElementById('character').innerText = `Character at (${currentChar.x}, ${currentChar.y}) - Health: ${currentChar.health}`;
            }
        }

        async function move(direction) {
            try {
                const response = await fetch('/move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-player-id': playerId
                    },
                    body: JSON.stringify({ direction })
                });

                if (!response.ok) {
                    throw new Error('Move failed');
                }

                // No need to manually update map, WebSocket will handle it
            } catch (error) {
                console.error('Error moving:', error);
            }
        }

        connectWebSocket();
    </script>
</body>
</html>