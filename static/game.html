<!DOCTYPE html>
<html>
<head>
    <title>Simple Game</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #character { font-size: 24px; margin: 20px; }
        #map { display: grid; grid-template-columns: repeat(10, 30px); grid-template-rows: repeat(10, 30px); margin: 20px auto; border: 1px solid black; width: 300px; height: 300px; }
        .tile { width: 30px; height: 30px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .empty { background-color: #f0f0f0; }
        .wall { background-color: #666; }
        .player { background-color: #ff0; }
        button { margin: 10px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h1>Simple Character Game</h1>
    <div id="character">Character at (0, 0) - Health: 100</div>
    <div id="map"></div>
    <div>
        <button onclick="move('up')">Up</button><br>
        <button onclick="move('left')">Left</button>
        <button onclick="move('right')">Right</button><br>
        <button onclick="move('down')">Down</button>
    </div>
    <script>
        let ws;
        let playerId = localStorage.getItem('playerId');

        if (!playerId) {
            playerId = generatePlayerId();
            localStorage.setItem('playerId', playerId);
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function connectWebSocket() {
            ws = new WebSocket('ws://127.0.0.1:8080/ws', [], {
                headers: { 'x-player-id': playerId }
            });

            // WebSocket constructor doesn't support headers in browser
            // We need to use a different approach - send the player ID in the first message
            ws.onopen = function(event) {
                console.log('WebSocket connected, sending player ID:', playerId);
                ws.send(JSON.stringify({ playerId: playerId }));
                // Wait a bit for the server to process the player ID before updating map
                setTimeout(updateMap, 100);
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateMapFromData(data.players, data.map);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onclose = function(event) {
                console.log('WebSocket closed, reconnecting...');
                setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        async function updateMap() {
            try {
                const [mapResponse, charResponse] = await Promise.all([
                    fetch('/map'),
                    fetch('/character', {
                        headers: { 'x-player-id': playerId }
                    })
                ]);

                if (!mapResponse.ok || !charResponse.ok) {
                    throw new Error('Failed to fetch game data');
                }

                const map = await mapResponse.json();
                const char = await charResponse.json();
                updateMapFromData({ [playerId]: char }, map);
            } catch (error) {
                console.error('Error updating map:', error);
            }
        }

        function updateMapFromData(players, map) {
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';

            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile ' + map.tiles[y][x];

                    let isPlayerHere = false;
                    for (const [id, char] of Object.entries(players)) {
                        if (x === char.x && y === char.y) {
                            tile.className += ' player';
                            tile.innerText = id === playerId ? 'P' : 'O'; // P for current player, O for others
                            isPlayerHere = true;
                            break;
                        }
                    }

                    if (!isPlayerHere && map.tiles[y][x] === 'wall') {
                        tile.innerText = '#';
                    }
                    mapDiv.appendChild(tile);
                }
            }

            const currentChar = players[playerId];
            if (currentChar) {
                document.getElementById('character').innerText = `Character at (${currentChar.x}, ${currentChar.y}) - Health: ${currentChar.health}`;
            }
        }

        async function move(direction) {
            try {
                const response = await fetch('/move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-player-id': playerId
                    },
                    body: JSON.stringify({ direction })
                });

                if (!response.ok) {
                    throw new Error('Move failed');
                }

                // No need to manually update map, WebSocket will handle it
            } catch (error) {
                console.error('Error moving:', error);
            }
        }

        connectWebSocket();
    </script>
</body>
</html>